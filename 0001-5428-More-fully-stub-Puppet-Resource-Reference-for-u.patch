From ff9e2425a58bb2b1ab836e440c3344b4012623c5 Mon Sep 17 00:00:00 2001
From: Jacob Helwig <jacob@puppetlabs.com>
Date: Fri, 25 Feb 2011 17:03:56 -0800
Subject: [PATCH/puppet] (#5428) More fully "stub" Puppet::Resource::Reference for use with storedconfigs

The Puppet::Resource::Reference class wasn't stubbing enough of the 0.25.x
behavior to satisfy the needs of storedconfigs.  Since P::R::Reference,
and Puppet::Resource were merged as part of 2.6.x, we can pretend that
P::Resource is P::R::Reference for the purposes of loading data from
storedconfigs.  This should still satisfy the over-the-wire serialization
needs of 0.25.x.

This also changes internal references to @parameters in
Puppet::Resource(::Reference) to go through a parameters method.  This
allows us to "initialize" this instance variable lazily, since loading via
YAML bypasses the normal initialize method.

Paired-with: Daniel Pittman <daniel@puppetlabs.com>
Reviewed-by: Markus Roberts <markus@puppetlabs.com>
---
 lib/puppet/resource.rb     |   35 +++++++++++++++++++----------------
 spec/unit/resource_spec.rb |   26 ++++++++++++++++++++++++--
 2 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/lib/puppet/resource.rb b/lib/puppet/resource.rb
index e832804..e47fc7e 100644
--- a/lib/puppet/resource.rb
+++ b/lib/puppet/resource.rb
@@ -5,6 +5,11 @@ require 'puppet/util/pson'
 # The simplest resource class.  Eventually it will function as the
 # base class for all resource-like behaviour.
 class Puppet::Resource
+  # This stub class is only needed for serialization compatibility with 0.25.x.
+  # Specifically, it exists to provide a compatibility API when using YAML
+  # serialized objects loaded from StoreConfigs.
+  Reference = Puppet::Resource
+
   include Puppet::Util::Tagging
 
   require 'puppet/resource/type_collection_helper'
@@ -104,7 +109,7 @@ class Puppet::Resource
   # be overridden at some point, but this works for now.
   %w{has_key? keys length delete empty? <<}.each do |method|
     define_method(method) do |*args|
-      @parameters.send(method, *args)
+      parameters.send(method, *args)
     end
   end
 
@@ -112,13 +117,13 @@ class Puppet::Resource
   # to lower-case symbols.
   def []=(param, value)
     validate_parameter(param) if validate_parameters
-    @parameters[parameter_name(param)] = value
+    parameters[parameter_name(param)] = value
   end
 
   # Return a given parameter's value.  Converts all passed names
   # to lower-case symbols.
   def [](param)
-    @parameters[parameter_name(param)]
+    parameters[parameter_name(param)]
   end
 
   def ==(other)
@@ -140,11 +145,11 @@ class Puppet::Resource
 
   # Iterate over each param/value pair, as required for Enumerable.
   def each
-    @parameters.each { |p,v| yield p, v }
+    parameters.each { |p,v| yield p, v }
   end
 
   def include?(parameter)
-    super || @parameters.keys.include?( parameter_name(parameter) )
+    super || parameters.keys.include?( parameter_name(parameter) )
   end
 
   # These two methods are extracted into a Helper
@@ -170,14 +175,6 @@ class Puppet::Resource
     end
   end
 
-  # This stub class is only needed for serialization compatibility with 0.25.x
-  class Reference
-    attr_accessor :type,:title
-    def initialize(type,title)
-      @type,@title = type,title
-    end
-  end
-
   # Create our resource.
   def initialize(type, title = nil, attributes = {})
     @parameters = {}
@@ -204,7 +201,7 @@ class Puppet::Resource
     tag(self.type)
     tag(self.title) if valid_tag?(self.title)
 
-    @reference = Reference.new(@type,@title) # for serialization compatibility with 0.25.x
+    @reference = self # for serialization compatibility with 0.25.x
     if strict? and ! resource_type
       if @type == 'Class'
         raise ArgumentError, "Could not find declared class #{title}"
@@ -234,7 +231,7 @@ class Puppet::Resource
 
   # Produce a simple hash of our parameters.
   def to_hash
-    parse_title.merge @parameters
+    parse_title.merge parameters
   end
 
   def to_s
@@ -256,7 +253,7 @@ class Puppet::Resource
   # Convert our resource to Puppet code.
   def to_manifest
     "%s { '%s':\n%s\n}" % [self.type.to_s.downcase, self.title,
-      @parameters.collect { |p, v|
+      parameters.collect { |p, v|
         if v.is_a? Array
           "    #{p} => [\'#{v.join("','")}\']"
         else
@@ -422,4 +419,10 @@ class Puppet::Resource
       return { :name => title.to_s }
     end
   end
+
+  def parameters
+    # @parameters could have been loaded from YAML, causing it to be nil (by
+    # bypassing initialize).
+    @parameters ||= {}
+  end
 end
diff --git a/spec/unit/resource_spec.rb b/spec/unit/resource_spec.rb
index ff31b24..4c1dc49 100755
--- a/spec/unit/resource_spec.rb
+++ b/spec/unit/resource_spec.rb
@@ -99,11 +99,11 @@ describe Puppet::Resource do
   end
 
   it 'should fail if strict is set and type does not exist' do
-    lambda { Puppet::Resource.new('foo', 'title', {:strict=>true}) }.should raise_error(ArgumentError, 'Invalid resource type foo') 
+    lambda { Puppet::Resource.new('foo', 'title', {:strict=>true}) }.should raise_error(ArgumentError, 'Invalid resource type foo')
   end
 
   it 'should fail if strict is set and class does not exist' do
-    lambda { Puppet::Resource.new('Class', 'foo', {:strict=>true}) }.should raise_error(ArgumentError, 'Could not find declared class foo') 
+    lambda { Puppet::Resource.new('Class', 'foo', {:strict=>true}) }.should raise_error(ArgumentError, 'Could not find declared class foo')
   end
 
   it "should fail if the title is a hash and the type is not a valid resource reference string" do
@@ -463,6 +463,28 @@ describe Puppet::Resource do
     end
   end
 
+  describe "when loading 0.25.x storedconfigs YAML" do
+    before :each do
+      @old_storedconfig_yaml = %q{--- !ruby/object:Puppet::Resource::Reference
+builtin_type:
+title: /tmp/bar
+type: File
+}
+    end
+
+    it "should deserialize a Puppet::Resource::Reference without exceptions" do
+      lambda { YAML.load(@old_storedconfig_yaml) }.should_not raise_error
+    end
+
+    it "should deserialize as a Puppet::Resource::Reference as a Puppet::Resource" do
+      YAML.load(@old_storedconfig_yaml).class.should == Puppet::Resource
+    end
+
+    it "should to_hash properly" do
+      YAML.load(@old_storedconfig_yaml).to_hash.should == { :path => "/tmp/bar" }
+    end
+  end
+
   describe "when converting to a RAL resource" do
     it "should use the resource type's :new method to create the resource if the resource is of a builtin type" do
       resource = Puppet::Resource.new("file", @basepath+"/my/file")
-- 
1.7.4.1

